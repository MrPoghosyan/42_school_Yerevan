ARG="4 67 3 87 23"; ./push_swap $ARG | wc -l

📌 Պարզաբանում՝
wc -l Հաշվում է, թե քանի տող է ծրագիրն արտածում։

ARG=$(...) Այդ ամբողջ արդյունքը դնում է ARG փոփոխականի մեջ։

ARG=$(shuf -i 1-1000 -n 5 | tr '\n' ' '); echo "ARGS: $ARG"; ./push_swap $ARG | ./checker_linux $ARG

📌 Բացատրություն:
shuf — գործիք է, որը նախատեսված է տողերի կամ թվերի խառնման (պատահականացնելու) համար։

   -i 1-100 — թիվերի միջակայք՝ 1-ից մինչև 100։

   -n 5 — որքան թվեր ընտրել (այստեղ՝ 5 հատ):


🔍 Ի՞նչ է անում tr:
tr — նշանակում է translate (թարգմանել/փոխարինել), սա հրաման է, որը փոխարինում է մեկ սիմվոլը մեկ ուրիշով։

   '\n' — նոր տողի սիմվոլ է (line break)։

   ' ' — սովորական բացատ։

✓✅echo — Տեսնել արգումենտներ։

ARG=$(shuf -i 1-10000 -n 500 | tr '\n' ' '); ./push_swap $ARG | wc -l

time ./push_swap 4 5 895 "46454 68764 121 -79"  
rra
pb
pb
pb
rra
pb
pa
pa
pa
pa

real    0.00s
user    0.00s
sys     0.00s
cpu     78%

📌 Բացատրություն:
real  0.00s  ← ընդհանուր անցած ժամանակը (սկսելուց մինչև ավարտը)
user  0.00s  ← ժամանակը, որն օգտագործվել է պրոցեսորի կողմից հաշվարկների համար
sys   0.00s  ← ժամանակը, որն օգտագործվել է միջուկի կողմից (օրինակ՝ համակարգային կանչերի համար)
cpu   78%    ← պրոցեսորի օգտագործման տոկոսը տվյալ ծրագրի աշխատանքի ընթացքում


🧠 Ինչպե՞ս է checker-ը հասկանում, որ այլևս հրահանգներ չկան։
 Երբ դու կարդում ես հրահանգները ստանդարտ մուտքից, օրինակ՝ օգտագործելով get_next_line(stdin) կամ read() ցիկլում, այդ ցիկլը շարունակվում է այնքան ժամանակ, քանի դեռ get_next_line-ը շարունակում է վերադարձնել տողեր։ Երբ հասնում է մուտքի վերջը (EOF - End Of File), get_next_line-ը վերադարձնում է NULL։

📥 Ի՞նչ է նշանակում “մուտքի վերջ”։
Եթե հրահանգները մուտքագրում ես ձեռքով տերմինալում, ապա մուտքի վերջը (EOF) կարող ես կանչել հետևյալ կերպ․

Ctrl + D՝ Linux/macOS-ում

Ctrl + Z, ապա Enter՝ Windows-ում


Եթե հրահանգները փոխանցում ես ֆայլից՝
   bash:
   ./checker 3 2 1 0 < instructions.txt

Ապա EOF-ը հասանելի կլինի ֆայլի վերջում և ավտոմատ  կլինի։

